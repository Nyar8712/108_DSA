# Hash Table 雜湊表
## 原理
以chained方式實作雜湊表時，首先利用一個陣列儲存定址的表。
* 對鍵入值行以下處理
  1. 先經過雜湊函數處理，會得到一個值以對應定址。
  2. 此時便在陣列後方透過鏈結串列做連接，用鏈結串列儲存該值。
  3. 如果處理時遇上碰撞問題(collision)，就將該值用鏈結串列接在後方。
  
剛剛提到了雜湊函數，則雜湊函數(hash function)是什麼？
### Hash Function概念
以chained來實作之雜湊函數可使用division method來作為雜湊函數。

假如array大小為m，鍵入的數值便會以h(key) = key mod m來算出其index。透過對key值取餘數，而餘數反應其地址，再透過該地址來儲存或尋找鍵入值。

什麼是碰撞(collision)？

當兩個鍵入值皆透過雜湊函數，但取得相同的餘數值之時，兩者的儲存位址便相同，稱之為碰撞。以chained實作解決碰撞問題非常好的一面便是使用鏈結串列的特性，當該index下已有先前的鍵入值時，便在其鏈結往下串下去，並儲存在該地方即可，如此一來便可透過同樣的index找到鍵入值，又能解決碰撞。

## 學習歷程
我首先從index部分開始著手，我上網找了一些網站資訊，得知這塊部分會是計算的核心。因為如何取餘數便是根據陣列長度來決定。在作業上則先給予長度一個初始值以方便確認狀態。

接著呢，便是試著把轉換後的值串到index後方，在這裡我犯了一個錯誤，不小心在串好後忘了把指標指向下一個鏈結，導致我接下來20分鐘內不斷插入失敗，得到同學提點後才發現問題。

我發現有些人選擇直接用array去儲存全部的內容，執行起來照樣完全沒問題，因此我就去試試看，發現效果差不多，寫起來更輕鬆方便，這時卻忽略一個大麻煩，空間。

我們在進行這些作業的撰寫和測試時，使用的測值量都非常少，因此用陣列進行時想當然爾輕鬆如也，不過假如今天要鍵入好幾萬筆呢？不就需要好幾萬空間的陣列，占用的空間超級大且很浪費，因array必須在設定時就決定其大小，不能增加不能減少，當不確定測值量時容易估算錯誤，估多浪費太多，估少放不下。

用此方法卻不同，因為用串接的方式，index部分可以遠少於鍵入值的量，畢竟碰撞部分都串接到後方就好了嘛，因此可以節省空間的使用，鏈結串列的特性就是空間不用先定義好，要多加一個就多，要少一個就少，非常靈活。

當然，沒有任何東西是完美的，今天測試值如果量並不大，並且在index部分分布不平均時，用鏈結串列反而會因此浪費空間，反倒不如用陣列來做。

我最後了解到各種方法的優缺點，不過以現在時代大部分都是非常非常大量的資料來說，可能還是用鏈結串列進行儲存會比較適合。

<br>  ![image](https://github.com/Nyar8712/homework/blob/master/IMG/hash.jpg)

## 流程圖

<br>  ![image](https://github.com/Nyar8712/homework/blob/master/IMG/hashset.jpg)

## 參照來源

我參考了以下網址來幫助我進行理解：

https://www.youtube.com/watch?v=O4dGJZ4J0Bk

http://alrightchiu.github.io/SecondRound/hash-tableintrojian-jie.html#dm

https://alrightchiu.github.io/SecondRound/hash-tablechaining.html

https://ithelp.ithome.com.tw/articles/10208884

本次作業我也跟上次一樣，與06170238賴祐全及06170243李騏宏一起討論如何進行和撰寫，關於概念部分是透過老師上課講解和影片來理解，程式邏輯部份兩位同學幫了很大的忙，不然我某些部份如contains還要卡死更久。
